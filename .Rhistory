qt(c(.025, .975), df=5)
?qt()
dt(.025, df=5)
dt(c(.025), df=5)
dt(c(.025), df=5)
qt(c(.025), df=5)
qt(.025, df=5)
qn(.025, df=5)
qnorm(.025)
-0.5 + 0.2*qnorm(.025)
0.5 + 0.2*qnorm(.025)
0.5 + 0.2*2
531 - 18.69
0.0289 + .0011*50
0.0289 + .0011*250
rep(1:4, 2)
rep(1:4, each = 2)       # not the same.
rep(1:4, c(2,2,2,2))     # same as second.
rep(1:4, c(2,1,2,1))
rep(1:4, each = 2, len = 4)    # first 4 only.
rep(1:4, each = 2, len = 10)   # 8 integers plus two recycled 1's.
rep(1:4, each = 2, times = 3)  # length 24, 3 complete replications
rep(1, 40*(1-.8)) # length 7 on most platforms
(1-.8)
rep(1, 40*(1-.8)+1e-7) # better
mySecFun<-function(v,M)
{
# compute the square of each element of v into u
u=c(0,0,0,0)
for(i in 1:length(v))
{
u[i]=myFirstFun(v[i]);
}
return(u)
}
Sqv=mySecFun(v)
Sqv
mySecFun<-function(v,M)
{
# compute the square of each element of v into u
u=c(0,0,0,0)
for(i in 1:length(v))
{
u[i]=myFirstFun(v[i]);
}
return(u)
}
v = 1
Sqv=mySecFun(v)
Sqv
x <- rpois(500, 4)
x
# function example - get measures of central tendency
# and spread for a numeric vector x. The user has a
# choice of measures and whether the results are printed.
mysummary <- function(x,npar=TRUE,print=TRUE) {
if (!npar) {
center <- mean(x); spread <- sd(x)
} else {
center <- median(x); spread <- mad(x)
}
if (print & !npar) {
cat("Mean=", center, "\n", "SD=", spread, "\n")
} else if (print & npar) {
cat("Median=", center, "\n", "MAD=", spread, "\n")
}
result <- list(center=center,spread=spread)
return(result)
}
# invoking the function
set.seed(1234)
x <- rpois(500, 4)
y <- mysummary(x)
Median= 4
MAD= 1.4826
# y$center is the median (4)
# y$spread is the median absolute deviation (1.4826)
y <- mysummary(x, npar=FALSE, print=FALSE)
# no output
# y$center is the mean (4.052)
# y$spread is the standard deviation (2.01927)
y$center
# example of a list with 4 components -
# a string, a numeric vector, a matrix, and a scaler
w <- list(name="Fred", mynumbers=a, mymatrix=y, age=5.3)
# example of a list containing two lists
w
w <- list(name="Fred", mynumbers=c(1,2), mymatrix=3, age=5.3)
w
rep(c(0,3), each = 5)
f1 <- function(x, y) {
x+y
}
f1( 3, 4)
f.good <- function(x, y) {
z1 <- 2*x + y
z2 <- x + 2*y
z3 <- 2*x + 2*y
z4 <- x/y
return(c(z1, z2, z3, z4))
}
f.good(1, 2)
f2 <- function(x, y) {
z1 <- x + y
z2 <- x + 2*y
list(z1, z2)
}
f2(2, 5)
for(i in 2:4) {
print(i)
}
2
f6 <- function(x) {
i <- 0
while(i < x) {
i <- i+1
y <- i*2
print(y)
}
return(y*2)
}
f6(3)
c <- f6(3)
c
setwd("datalab/Evaluacion/")
# Configura el ambiente para que se use el encoding utf-8, ya que el script
# lo corrí en MAC OS el capitan con idioma inglés.
Sys.setlocale("LC_ALL", 'en_US.UTF-8')
# Función para la carga de los datos desde el libro de excel
# usando el paquete readxl
library(readxl)
filename <- "refugios_nayarit.xlsx"
read_excel_allsheets <- function(filename) {
sheets <- readxl::excel_sheets(filename) # vector con el nombre de las hojas del excel
x <- lapply(sheets, function(X) readxl::read_excel(filename, sheet = X,
col_names = FALSE, skip = 5))
names(x) <- sheets
x
setwd("datalab/Evaluacion/")
source("helpers.R") # Carga funciones utiles para la carga y procesamiento de
)
setwd("datalab/Evaluacion/")
source("helpers.R") # Carga funciones utiles para la carga y procesamiento de
# de la base.
# Configura el ambiente para que se use el encoding utf-8, ya que el script
# lo corrí en MAC OS el capitan con idioma inglés.
Sys.setlocale("LC_ALL", 'en_US.UTF-8')
# Función para la carga de los datos desde el libro de excel
# usando el paquete readxl
library(readxl)
filename <- "refugios_nayarit.xlsx" # Se define el nombre del archivo de la base
db <- read_excel_allsheets(filename)
# Se hace un merge de las listas en la lista db.
db = Reduce(function(...) merge(..., all=T), db)
# Creación de un vector con el nombre de las columnas de la base
nombres <- c("no" , "refugio", "municipio", "direccion", "uso.del.inmueble", "servicios",
"capacidad.de.personas", "latitud.n", "longitud.w", "altitud.msnm", "responsable",
"telefono")
names(db) <- nombres
### Limpiando la base
# Eliminamos los registros que se hayan importado pero que no tengan No.
db <- db[!is.na(db$no),]
# Elimanos aquellos datos que no tengan latitud ni longitud
db <- db[!is.na(db$latitud.n),]
db <- db[!is.na(db$longitud.w),]
# Estandarización de caracteres al formato ddºmm'ss\"
# También se reasignamos las variables ya que están mal codificadas
db$lon = clean_chars(db$longitud.w)
db$lat = clean_chars(db$latitud.n)
#install.packages("readxl")
#install.packages("sp")
setwd("datalab/Evaluacion/")
source("helpers.R") # Carga funciones utiles para la carga y procesamiento de
# de la base.
# Configura el ambiente para que se use el encoding utf-8, ya que el script
# lo corrí en MAC OS el capitan con idioma inglés.
Sys.setlocale("LC_ALL", 'en_US.UTF-8')
# Función para la carga de los datos desde el libro de excel
# usando el paquete readxl
library(readxl)
filename <- "refugios_nayarit.xlsx" # Se define el nombre del archivo de la base
db <- read_excel_allsheets(filename)
# Se hace un merge de las listas en la lista db.
db = Reduce(function(...) merge(..., all=T), db)
# Creación de un vector con el nombre de las columnas de la base
nombres <- c("no" , "refugio", "municipio", "direccion", "uso.del.inmueble", "servicios",
"capacidad.de.personas", "latitud.n", "longitud.w", "altitud.msnm", "responsable",
"telefono")
names(db) <- nombres
### Limpiando la base
# Eliminamos los registros que se hayan importado pero que no tengan "No."
db <- db[!is.na(db$no),]
# Elimanos aquellos datos que no tengan latitud ni longitud
db <- db[!is.na(db$latitud.n),]
db <- db[!is.na(db$longitud.w),]
# Creamos nuevas variables con la latitud y longitud en formato ddºmm'ss\"
db$lon = clean_chars(db$longitud.w)
db$lat = clean_chars(db$latitud.n)
#install.packages("readxl")
#install.packages("sp")
setwd("datalab/Evaluacion/")
source("helpers.R") # Carga funciones utiles para la carga y procesamiento de
# de la base.
# Configura el ambiente para que se use el encoding utf-8, ya que el script
# lo corrí en MAC OS el capitan con idioma inglés.
Sys.setlocale("LC_ALL", 'en_US.UTF-8')
# Función para la carga de los datos desde el libro de excel
# usando el paquete readxl
library(readxl)
filename <- "refugios_nayarit.xlsx" # Se define el nombre del archivo de la base
db <- read_excel_allsheets(filename)
# Se hace un merge de las listas en la lista db.
db = Reduce(function(...) merge(..., all=T), db)
# Creación de un vector con el nombre de las columnas de la base
nombres <- c("no" , "refugio", "municipio", "direccion", "uso.del.inmueble", "servicios",
"capacidad.de.personas", "latitud.n", "longitud.w", "altitud.msnm", "responsable",
"telefono")
names(db) <- nombres
### Limpiando la base
# Eliminamos los registros que se hayan importado pero que no tengan "No."
db <- db[!is.na(db$no),]
# Elimanos aquellos datos que no tengan latitud ni longitud
db <- db[!is.na(db$latitud.n),]
db <- db[!is.na(db$longitud.w),]
# Creamos nuevas variables con la latitud y longitud en formato ddºmm'ss\"
db$lon = clean_chars(db$longitud.w)
db$lat = clean_chars(db$latitud.n)
View(db)
db$lon = paste(db$lon, "W")
db$lat = paste(db$lat, "N")
#install.packages("readxl")
#install.packages("sp")
setwd("datalab/Evaluacion/")
source("helpers.R") # Carga funciones utiles para la carga y procesamiento de
# de la base.
# Configura el ambiente para que se use el encoding utf-8, ya que el script
# lo corrí en MAC OS el capitan con idioma inglés.
Sys.setlocale("LC_ALL", 'en_US.UTF-8')
# Función para la carga de los datos desde el libro de excel
# usando el paquete readxl
library(readxl)
filename <- "refugios_nayarit.xlsx" # Se define el nombre del archivo de la base
db <- read_excel_allsheets(filename)
# Se hace un merge de las listas en la lista db.
db = Reduce(function(...) merge(..., all=T), db)
# Creación de un vector con el nombre de las columnas de la base
nombres <- c("no" , "refugio", "municipio", "direccion", "uso.del.inmueble", "servicios",
"capacidad.de.personas", "latitud.n", "longitud.w", "altitud.msnm", "responsable",
"telefono")
names(db) <- nombres
### Limpiando la base
# Eliminamos los registros que se hayan importado pero que no tengan "No."
db <- db[!is.na(db$no),]
# Elimanos aquellos datos que no tengan latitud ni longitud
db <- db[!is.na(db$latitud.n),]
db <- db[!is.na(db$longitud.w),]
# Creamos nuevas variables con la latitud y longitud en formato ddºmm'ss\"
# estandarizando los caracteres distintos al formato. Adicionamos
db$lon = clean_chars(db$longitud.w)
db$lat = clean_chars(db$latitud.n)
db$lon = paste(db$lon, "W")
db$lat = paste(db$lat, "N")
# Conversión de las variables anteriores a formato decimal
db$lat = dms2dec(db$lat)
db$lon = dms2dec(db$lon)
db <- db[!is.na(db$lat),]
db <- db[!is.na(db$lon),]
# Acotamos la región de estudio de acuerdo a: http://www.nayarit.gob.mx/estado/
# las coordenadas extremas son:
# Al norte 23º 05' y al sur 20º 36' de latitud norte.
# Al este 103º 43', al oeste 105º46' de longitud oeste.
extremos <- c("23º05'00\" N", "20º36'00\" N", "103º43'00\" W", "105º46'00\" W")
extremos <- dms2dec(extremos)
names(extremos) <- c("norte", "sur", "este", "oeste")
extremos
db <- db[(db$lat >= extremos["sur"] & db$lat <= extremos["norte"]), ]
db <- db[(db$lon >= extremos["oeste"] & db$lon <= extremos["este"]), ]
db[,c("lat", "latitud.n")]
db[,c("lon", "longitud.w")]
person <- c(-104.70, 21.00)
names(person) <- c("lon", "lat")
plot(db$lon, db$lat)
points(person["lon"], person["lat"], col="red", pch=19)
install.packages("geosphere")
# Calculo de la distancia de la persona a los diferentes centros.
library(geosphere)
dist <- rbind(person, db[, c("lon", "lat")])
distances <-  as.data.frame(distm(dist, fun = distHaversine))
distances <- distances[,"V1"]
distances <- distances[-1]
names(distances) <- c("distancia")
distances <- as.data.frame(cbind(distancia = distances,
lon = db$lon, lat = db$lat,
no = db$no))
distances <-  distances[order(distances$distancia),]
distances <- distances[1:3,]
points(distances$lon, distances$lat, col="blue", pch=19)
db$lat <- dms2dec(db$latitud.n)
db$longitud.w2 <- dms2dec(db$longitud.w)
###### mapa
library(sp)
ub_mexico = "MEX_adm2.rds"
mexico <- readRDS(ub_mexico)
str(mexico)
nayarit <- mexico[mexico$NAME_1=="Nayarit",]
str(nayarit)
plot(nayarit)
points(db$lon, db$lat, col="blue", pch=19)
points(person["lon"], person["lat"], col="red", pch=19)
points(distances$lon, distances$lat, col="green", pch=19)
